# 内部类

> 内部类就是定义在一个类里面的类。

比如：

```java
class A {
    // 内部类
    class B {
        
    }
}
```

## 内部类创建对象

内部类创建对象的语法：

```java
外部类名.内部类名 对象名 = new 外部类对象().内部类对象();
```

比如：

```java
A.B b = new A().new B();
```

- **为什么定义内部类对象如此复杂？**

  是为了区分同名内部类，比如两个类中都定义了同名内部类，那么就通过外部类名作为标识来区分内部类。

```java
/*
A 和 C 中都有 B 类，于是通过 A.B 和 A.C 类区分
*/
class A {
    class B {}
}

class C {
    class B {}
}
```



# 成员访问细节

内部类与外部类成员访问的细节，代码材料：

![image-20240724204152135](assets/image-20240724204152135.png)

创建内部类对象：
![image-20240724204239968](assets/image-20240724204239968.png)

调用内部类的成员：
![image-20240724204439680](assets/image-20240724204439680.png)

![image-20240724204500066](assets/image-20240724204500066.png)

## 内部类访问外部类成员

> 直接访问，包括私有成员。

![image-20240724210029065](assets/image-20240724210029065.png)

## 外部类访问内部类成员

> 不能直接访问，需要通过内部类对象访问。

![image-20240724210232787](assets/image-20240724210232787.png)

注意，在外部类中并没有通过外部类名标识创建内部类对象，而是直接创建，因为外部类能直接找到它内部的成员，不存在同名内部类的情况。



# 案例

当外部类和内部类中成员变量重名时，如何访问？

代码材料：

![image-20240724210658673](assets/image-20240724210658673.png)

外部类、内部类和内部类方法中都存在同名变量`num`，需要输出30、20和10。

输出30很简单，就近原则，直接访问局部变量`num`：

![image-20240724210947664](assets/image-20240724210947664.png)

20是内部类中的成员，当前方法是内部类的方法，所以可以通过`this`来访问20：

![image-20240724211016850](assets/image-20240724211016850.png)

如何访问10？10是外部类的成员变量，访问20可以通过`this`即当前实例`Inner`。要访问10，也可以通过`Outer`实例。关键是如何获取`Outer`的实例，用`this`不行，因为此处的`this`指代的是`Inner`。所以要区分`this`，只需用`Outer`类名标识`this`即可表示`Outer`实例：

![image-20240724211446938](assets/image-20240724211446938.png)

![image-20240724211530482](assets/image-20240724211530482.png)



# 内部类种类

> 1. 成员内部类
> 2. 静态内部类
> 3. 局部内部类
> 4. 匿名内部类

上述所讲的就是成员内部类，它的位置和成员方法、变量是一个位置。



# 静态内部类

> 由`static`修饰的成员内部类。

比如：

```java
class Outer {
   	// static 修饰
    static class Inner {}
}
```

普通类不能被`static`修饰，只有内部类才能，因为内部类是外部类的一个成员，所以可以被修饰。

## 创建对象

```java
外部类名.内部类名 对象名 = new 外部类名.内部类对象();
```

比如：

```java
Outer.Inner in = new Outer.Inner();
```

![image-20240724213301040](assets/image-20240724213301040.png)

![image-20240724213350168](assets/image-20240724213350168.png)

![image-20240724213356030](assets/image-20240724213356030.png)

如果调用的方法是静态的，可以直接类名调用：

![image-20240724213537031](assets/image-20240724213537031.png)

![image-20240724213545987](assets/image-20240724213545987.png)

![image-20240724213356030](assets/image-20240724213356030.png)

## 注意

> 静态只能访问静态，所以在静态内部类中访问外部类的成员时，能直接访问静态成员，但是不能直接访问非静态成员，如果要访问非静态成员，需要外部类对象。



# 局部内部类

> 定义在方法、代码块、构造器等执行体中的类。

比如定义在方法中的类：
![image-20240724214213437](assets/image-20240724214213437.png)

如何创建局部内部类的对象？用外部类标识吗？

不行，因为这个类存在于方法中，只有当方法执行时，这个类才会存在，所以要创建该对象需要在方法中创建：
![image-20240724214456643](assets/image-20240724214456643.png)

调用其`method()`，也要在`show()`中：

![image-20240724214619436](assets/image-20240724214619436.png)

而要执行还得调用`show()`：

![image-20240724214708296](assets/image-20240724214708296.png)

![image-20240724214842693](assets/image-20240724214842693.png)

可谓麻烦至极，这个语法非常鸡肋，用的人也很少。



# 匿名内部类

> 匿名内部类本质上是一个特殊的局部内部类(定义在方法内部)。
>
> 前提：需要存在一个接口或类。

语法：

```java
new 类名 | 接口名 (){}
```

代码材料：

![image-20240726185729758](assets/image-20240726185729758.png)

接口【Inter】，有方法【show()】，测试方法【test()】接受【Inter】类型的参数，并调用其【show()】。

调用【test()】，由于其接受【Inter】类型的参数，所以要传入一个接口对象，因此可以用对象多态将实现类对象作为参数传递：

![image-20240726190047968](assets/image-20240726190047968.png)

调用【test()】：

![image-20240726190125344](assets/image-20240726190125344.png)

结果：

![image-20240726190142817](assets/image-20240726190142817.png)

在这种情况下，为了调用【test()】，首先是创建了【Inter】的实现类，然后实现了【show()】，再通过实现类对象入参调用。仅仅是调用了参数是接口的方法就需要3步操作，但用匿名内部类的形式只需要一行代码：

![image-20240726190626377](assets/image-20240726190626377.png)

结果：

![image-20240726190732832](assets/image-20240726190732832.png)

匿名内部类的语法的另一层含义：

```java
new 接口名() {} // 表示 实现 这个接口
new 类名() {} // 表示 继承 这个类
```

从原来的3步直接简化成现在的一步，匿名内部类让代码变得更加简洁了。另外，在定义匿名内部类的时候，用到了【new】关键字，因此匿名内部类同时还在创建对象，所以语法的另一层含义是：

```java
new 接口名() {} // 创建接口对象
new 类名() {} // 创建类对象
```

综上，其语法的含义是：

```java
new 接口名() {} // 表示 实现 这个接口，同时 创建 实现类对象
new 类名() {} // 表示 继承 这个类，同时 创建 类对象
```

## 好处

> 匿名内部类可以让代码变得更加简洁，同时在定义类的时候进行实例化。

## 局限性

并不是所有时候都适合用匿名内部类来创建接口的实现类对象，当一个接口的抽象方法很多时：

![image-20240726191824495](assets/image-20240726191824495.png)

匿名内部类就需要实现接口中的所有抽象方法：
![image-20240726191909661](assets/image-20240726191909661.png)

代码的可读性低，且雍总。所以，匿名内部类只适合当接口或类中的抽象方法很少时使用，如果抽象方法很多，远不如直接定义一个实现类和子类直观。
