# 继承介绍

> 所谓继承，就是<font color='#E0361A'>**类与类产生关系**</font>，什么样的关系？子类与父类的关系，<font color='409EFF'>**子类**</font>可以<font color='409EFF'>**直接使用父类**</font>中<font color='409EFF'>**非私有成员**。</font>

为什么要让类与类之间产生关系？举个例子，有两个类：`Coder` 和 `Manager`，分别是程序员类和项目经理类：

```java
class Coder{
    String name;	// 姓名
    Integer age;	// 年龄
    Double salary;	// 薪资
}

class Manager{
    String name;	// 姓名
    Integer age;	// 年龄
    Double salary;	// 薪资
}
```

观察这两个类，会发现它们都有相同的成员，`name`、`age`、`salary`。这两个类维护的信息都是一样的，假设现在正在开发一款人员管理系统，需要对员工信息进行管理，此时已经创建好了一个程序员类 `Coder`，管理程序员相关信息，一个项目经理类 `Manager` 管理项目经理的相关信息，将来是不是还需要编写一个`Hr`类来管理人事的相关信息？那么这个 `Hr` 类是不是也是维护 `name`、`age`、`salary`？然后把重复的内容再写一遍：

```java
class Hr{
    String name;	// 姓名
    Integer age;	// 年龄
    Double salary;	// 薪资
}
```

不觉得这样写显得代码很臃肿吗？那么这个时候就需要优化代码了。现在发现多个类之间存在相同的类容，或者说共性的内容。那么可以考虑将相同的内容向上进行抽取，将相同的内容向上抽取到一个员工类`Employee`中：

```java
class Employee {
    String name;	// 姓名
    Integer age;	// 年龄
    Double salary;	// 薪资
}

class Coder{

}

class Manager{

}
```

然后让 `Coder` 和 `Manager` 与 `Employee` 建立关系，当关系建立后，`Employee` 中的 `name`、`age`、`salary` 在 `Coder` 和 `Manager` 中就可以直接使用。只需让 `Employee` 充当父类， `Coder` 和 `Manager` 充当子类，那么 `Employee` 中非私有的成员，`Coder` 和 `Manager` 就可以直接访问。这就是所谓的继承，就是让类与类产生父子关系。

可是类与类如何产生父子关系？



# extends

`extends` 关键字能让类与类产生父子关系。

格式：

```java
public class 子类名 extends 父类名 {}
```

比如：

```java
public class Zi extends Fu {}
```

- `Fu`：是父类，也被称为基类、超类
- `Zi`：是子类，也被称为派生类



# 案例

准备一个测试类和两个子类：

![image-20240715111821186](assets/image-20240715111821186.png)

这里有个细节：`Coder` 和 `Manager` 是直接写在 `ExtendsDome` 中的。以前的写法是一个 `.java` 文件对应一个 `class` 但其实一个 `.java` 文件中可以编写多个 `class` 。不过需要保证多个类之间是平级关系，即不能写成嵌套关系：

![image-20240715111912193](assets/image-20240715111912193.png)

这样写不会报错，事实上这样的写法使用了一种叫做内部类的技术，这种写法创建对象不再是之前的格式：

![image-20240715112118701](assets/image-20240715112118701.png)

会报错，这种内部类创建对象的格式为：

```java
外部类名.内部类名 对象名 = new 外部类名().new 内部类名()
```

![image-20240715112356656](assets/image-20240715112356656.png)

只有保证是平级关系，才能使用之前创建对象的方法：

![image-20240715112521751](assets/image-20240715112521751.png)

除此之外，还需要保证，多个 `class` 中只能有一个类被 `public` 修饰，如果有多个会报错：

![image-20240715112702912](assets/image-20240715112702912.png)

原因：如果类用 `public` 修饰，那么就限制了类名与 `.java` 文件名必须保持一致。现在的类有3个，而文件名只有1个，是不可能保持一致的，所以 `.java` 文件中如果编写了多个类，只能由一个被 `public` 修饰。

其实这种写法是不规范的，规范的写法是：一个 `.java` 文件对应一个 `class` 。之所以这样写，是为了演示继承更加方便。

`Coder` 和 `Manager` 都有共性的内容：

![image-20240715113514971](assets/image-20240715113514971.png)

因此向上抽取到一个员工类中：

![image-20240715113630636](assets/image-20240715113630636.png)

然后 `Coder` 和 `Manager` 继承至 `Employee` 与之建立父子关系：

![image-20240715113753503](assets/image-20240715113753503.png)

现在产生关系后，子类就能直接使用父类中非私有成员：

![image-20240715114018381](assets/image-20240715114018381.png)

如果是私有成员，子类不能使用：

![image-20240715114120932](assets/image-20240715114120932.png)

一个标准的实体或者 `java bean` 成员变量都是要求私有的，如果都私有就意味着子类无法使用，为了避免这种情况，在私有变量的同时，也要求为其提供 `getter` 和 `setter` 以供子类或其他类能访问：

```java
// Employee属性私有，但是提供了getter和setter
class Employee {
    private String name;
    private Integer age;
    private Double salary;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getSalary() {
        return salary;
    }

    public void setSalary(Double salary) {
        this.salary = salary;
    }
}
```

![image-20240715115141454](assets/image-20240715115141454.png)

![image-20240715115240518](assets/image-20240715115240518.png)

虽然成员变量被私有，但是可以提供 `getter` 和 `setter` 方法，这些方法是公共的，子类是可以继承使用的。



# 继承的好处

> 提高代码的复用性，重复的内容在父类中定义，子类继承即可，无需重复定义。



# 继承使用时机

继承不可盲目使用，需要存在一定的合理性。举个例子：共性的内容，并没有定义在 `Employee` 中，而是定义在 `Coder` 中，由 `Manager` 去继承 `Coder` ：

```java
class Coder {
    private String name;
    private Integer age;
    private Double salary;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getSalary() {
        return salary;
    }

    public void setSalary(Double salary) {
        this.salary = salary;
    }
}

class Manager extends Coder {

}
```

虽然， `Manager` 也可以使用 `Coder` 的成员：

![image-20240715120028547](assets/image-20240715120028547.png)

那为什么还要向上抽取出一个共同的父类呢？其实这种设计是不合理的， `Manager` 继承至 `Coder` ，想想看 `Manager` 是子类， `Coder` 是父类，项目经理难不成还要继承至程序员吗？这合理吗？这明显不合理。所以继承体系设计要存在合理性。不管是项目经理继承至程序员，还是程序员继承至项目经理都不合适，但是向上抽取出一个员工类，项目经理是员工的一种，程序员也是员工的一种，这种设计就合理多了。

> 当类与类之间，<font color='E0361A'>**存在相同(共性)的内容**</font>，并且产生了<font color='E0361A'>**谁是谁的一种**</font>这样的关系时，可以考虑继承优化代码

比如， `Student` 类和 `Teacher` 类，它们都有共同的属性如姓名、年龄等，那么可以向上抽取出一个 `People` 类。又比如， `Dog` 类和  `Cat` 类，可以向上抽取出 `Animal` 类。



# 继承中成员访问特点

## 成员变量

在父子类中，如果出现重名的属性，优先使用谁呢？比如， `Fu` 类中有属性 `num` ， `Zi` 类中也有属性 `num` ，同时`Zi`中还要方法`method`，在`method`中输出`num`属性。`Zi` 类继承至`Fu`类，那么调用`Zi`的`method`，会输出什么呢？

![image-20240715145004949](assets/image-20240715145004949.png)

结果：![image-20240715144737347](assets/image-20240715144737347.png)

会输出20，也就是输出的是子类中的属性。这是为什么？这是因为本类中的方法调用成员变量时，实际上是使用`this`来调用的，也就是说这样的调用方法：

![image-20240715145510591](assets/image-20240715145510591.png)

等效于：

![image-20240715145528874](assets/image-20240715145528874.png)

只不过通常都将`this`省略掉了。而`this`指代的是当前的实例，这行代码是写在`Zi`类中的，即当前实例就是`Zi`对象，那么调用的`num`自然也是`Zi`的`num`，所以输出结果为20。

### super

如果非要用父类的`num`呢？就需要使用关键字`super`了。如同`this`指向的是当前实例一样，`super`指向的就是父类实例。

![image-20240715150658927](assets/image-20240715150658927.png)

结果：![image-20240715150712669](assets/image-20240715150712669.png)

问题：

![image-20240715151006402](assets/image-20240715151006402.png)

父类的`num`为10，子类为20，在`method`方法中又定义了局部变量`num`为30，如何打印出30、20、10？

打印30直接访问局部变量，打印20要访问当前实例的变量，打印10要访问父类的变量，所以答案为：

![image-20240715151242404](assets/image-20240715151242404.png)

结果：![image-20240715151255286](assets/image-20240715151255286.png)



## 成员方法

子类继承父类，子类是否可以自己继续定义方法？答案是肯定的。

既然子类可以继续定义方法，那么如果子类定义了一个和父类方法名一样的方法，但是逻辑却不一样，此时调用子类的方法，是执行父类方法的逻辑还是子类方法的逻辑？

![image-20240715152045274](assets/image-20240715152045274.png)

![image-20240715152106596](assets/image-20240715152106596.png)

结果：

![image-20240715152121665](assets/image-20240715152121665.png)

执行的是子类方法的逻辑。

> **方法声明一致：**
>
> ​	方法名一致，形参的个数、类型和顺序一致，返回值一致叫做方法声明一致，否则不一致。

父子类中，出现了方法声明一样的方法，在创建子类对象，调用对象方法时，会优先使用子类的方法逻辑。这虽然是就近原则现象，但其实是子类方法对父类方法进行了重写。

### 方法重写

与方法重载的对比，莫要混淆：

> **方法重载(Overload)：**
>
> ​	在同一个类中，方法名相同，形参不同(类型、个数和顺序不同)，与返回值无关
>
> **方法重写(Override)：**
>
> ​	在父子类中，方法声明一致的方法

![image-20240715155128053](assets/image-20240715155128053.png)

![image-20240715155134488](assets/image-20240715155134488.png)

如果改变子类的方法：

![image-20240715155238817](assets/image-20240715155238817.png)

那么调用的就是父类的方法：

![image-20240715155307587](assets/image-20240715155307587.png)

![image-20240715155316328](assets/image-20240715155316328.png)

此时子类的方法与父类的方法就不再是重写关系，而是重载关系：

![image-20240715155440365](assets/image-20240715155440365.png)

虽然不再同一个类中，但是它们存在继承关系，子类能继承父类的方法，想象成子类中也有父类的方法，然后对该方法进行了重载，等效于：

![image-20240715155549213](assets/image-20240715155549213.png)

所以`Z`对象调用`method`方法，发现没有参数，于是就调用了没有参数的方法。

检查一个方法是否为重写，最简单的办法就加`@Override`注解，如果没有报错，那么该方法是重写方法，反之则不是：

![image-20240715160050897](assets/image-20240715160050897.png)



