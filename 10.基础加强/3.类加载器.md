# 1 类加载器

> 类加载器的作用是负责将类的字节码文件加载到内存中(方法区内存)。

编写好的java文件经过javac编译后会产生一份字节码文件，当运行程序，字节码文件会加载到方法区内存中。而类加载器就是负责把字节码文件加载到方法区中。

## 1.1 加载时机

类加载器的加载时机：

加载时机总结就是：用到即加载。

- 【new】对象。
- 调用静态成员。
- 初始化继承体系，加载子类时，先加载父类。
- 反射加载类的字节码时。

## 1.2 加载过程

加载过程分为3个步骤：

1. 加载
2. 链接
3. 初始化

**一、加载**

- 通过包名+类名准确获取这个类，准备用流进行传输。

  ![image-20240926195647052](assets/image-20240926195647052.png)

- 将类加载到内存中。

  ![image-20240926195711798](assets/image-20240926195711798.png)

- 加载完毕，创建一个【Class】对象。

​	![image-20240926195726766](assets/image-20240926195726766.png)

java中万物皆对象，字节码文件也存在表示它的对象，就是【Class】。

【Class】对象保存了类的结构信息，例如类的属性、方法、父类等：

![image-20240926200035256](assets/image-20240926200035256.png)

**二、链接**

链接又分为3个小步骤：

1. **验证**：验证类是否符合JVM规范，安全性检查，防止恶意篡改字节码文件。
2. **准备**：为类的**静态变量**分配空间，并设置**默认值**。
3. **解析**：将常量池中的符号引用解析为直接引用。

**准备**步骤的细节：

设置静态变量的默认值，并非赋值，比如这样的静态变量：

```java
class Student{
    static String school = "北大";
}
```

在**准备**阶段仅仅是让【school】为【null】(引用类型默认值)：

```java
school = null;
```

而赋值为"北大"是在后面的**初始化**阶段。

**解析**步骤的细节：

**Q.什么是将符号引用解析为直接引用？**

A.举例：

```java
class B {
    C c = new C();
}

class C {
    
}
```

有两个类【B】和【C】，【B】中的成员【c】赋值为对象【C】。

```java
public static void main(String[] args) {
    ClassLoader classLoader = B.class.getClassLoader();

    while (true) {

    }
}
```

拿到【B】的类加载器。【B.class】表示【B】的字节码对象，而字节码对象会在类被加载到内存时创建，也就是说这一步会触发【B】类的加载。

**注意**：用【class】或**类加载器**触发类的加载行为，仅仅只完成类加载过程中的第一步：即**加载**过程。这意味着**链接**和**初始化**是并没有执行的。

类加载到内存中就会生成【Class】对象，该对象记录了类的结构，包括成员变量等， 也就是说会记录【B】的成员变量【c】，但是【c】现在还只是一个**符号**，因为【B】仅仅完成了**加载**过程，并没有执行**链接**过程，在**连接**过程中才会将符号引用解析为直接引用。

而完整的加载过程在加载时机中已经说过了，所以当【B】创建对象时：

```java
public static void main(String[] args) {
    ClassLoader classLoader = B.class.getClassLoader();
    new B();
    while (true) {

    }
}
```

会触发完整的类加载过程，然后执行**链接**过程，然后将符号引用解析为直接引用，也就是现在【c】不再是一个符号，而是一个引用，一个能接受【C】类型的引用地址的能力。

这就是**解析**。在这个过程中将符号引用解析为直接引用。

**注意**：解析并不是赋值，而是将符号引用解析为直接引用，可以这样来理解，只有解析为直接引用，这个变量才有能力去接收某某类型的地址值。