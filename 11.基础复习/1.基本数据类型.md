# int

## int除法设计理念

int作除法运算时，得到的是整数。若结果为小数，那么就会截断小数点后面的数，而取整数部分。如：

```java
int a = 5;
int b = 2;
System.out.println(a / b);	// 输出2，而不是2.5
```

Java 这样设计整数除法的行为（直接截断小数部分）主要基于以下几个核心原因：

1. **硬件操作的高效性**

- CPU 的整数除法指令天生就是截断余数的（如 x86 的 `DIV` 指令返回商和余数）

- 直接使用硬件行为效率最高，无需额外转换：

  ```java
  int a = 6, b = 4;
  int quotient = a / b;  // 直接对应1条CPU指令
  int remainder = a % b; // 另一条指令取余数(2)
  ```

2. **类型系统的严谨性**

- Java 强调**强类型**设计：`int / int` 必须产生 `int`

- 自动转为浮点数会破坏类型一致性：

  ```java
  int x = 10 / 4; // 必须为整数，不能是2.5
  ```

3. **与取模运算的数学一致性**

整数除法和取模运算(`%`)需满足数学关系：`(a / b) * b + (a % b) == a`，如果 `6 / 4 = 1.5`，就无法满足：

也就是a / b 的值为商，a % b 的值为余，余+(商*除数)才能得到被除数。

```java
1 * 4 + (6 % 4) = 4 + 2 = 6  // 整数除法成立
1.5 * 4 + ? = 6               // 浮点除法破坏等式
```

4. **历史兼容性**

- 继承了 C/C++ 的处理方式（Java 设计目标之一）

- 避免已有代码迁移时产生意外行为：

  ```c
  // C语言同样行为
  int a=6, b=4;
  double c = a/b; // 1.0
  ```

5. **明确性优于隐式转换**

- 设计哲学：要求开发者**显式**表达意图

- 防止无意间的性能损失（浮点运算比整数慢 3-10 倍）：

  ```java
  // 需要浮点结果时明确转换
  double c = (double)a / b; // 明确告知编译器需要浮点运算
  ```

## 实际工程意义

假设处理数组索引：

```java
int total = 1007;
int pageSize = 100;
int pages = total / pageSize; // 得到10（而非10.07）
```

如果自动转为浮点：

- 需要额外强制转换回整数
- 可能导致性能下降
- 小数部分在分页场景中无意义

## 如何得到除法的实际结果？

要获得精确的数学除法结果（保留小数部分），可通过以下任一方法**强制进行浮点数除法**：

| 方法         | 代码示例                            | 说明                   |
| :----------- | :---------------------------------- | :--------------------- |
| 显式类型转换 | `double c = (double)a / b;`         | 最推荐，意图最清晰     |
| 浮点数字面量 | `double c = a / 4.0;`               | 直接使用浮点常数       |
| 乘法转换     | `double c = 1.0 * a / b;`           | 利用乘法提升类型       |
| 强制整体转换 | `double c = (double)(a * 1.0 / b);` | 确保中间结果不丢失精度 |

## 方法 1：显式类型转换（最佳实践）

```java
int a = 6;
int b = 4;
double c = (double) a / b; // 将a转为double
System.out.println(c);     // 输出 1.5
```

- **原理**：将其中一个操作数转为浮点数，触发浮点除法
- **优势**：代码意图清晰，性能最佳

## 方法 2：使用浮点数字面量

```java
double c = a / 4.0;       // 直接使用浮点常数
// 或
double c = 6.0 / b;       // 如果直接使用数字
```

- **注意**：当分母是变量时，需用 `(double)b` 替代

## 方法 3：乘法转换技巧

```java
double c = 1.0 * a / b;   // 通过乘法提升表达式类型
```

- **原理**：`1.0 * a` 先将结果转为浮点
- **适用场景**：快速修改现有代码

## 方法 4：整体强制转换（避免中间计算丢失精度）

```java
double c = (double) a / b;  // 正确：先转换再除
// 错误示范：
double c = (double)(a / b); // 输出1.0（先整数除再转换）
```

### 特殊场景处理

**大整数除法**（防止溢出）：

```java
int big1 = 2_000_000_000;
int big2 = 1_000_000_000;
double result = (double) big1 / big2; // 正确得到2.0
// 而非 big1/big2=2（整数除法）再转2.0
```

**分数运算**（需要更高精度）：

```java
import java.math.BigDecimal;

BigDecimal bd1 = new BigDecimal("6");
BigDecimal bd2 = new BigDecimal("4");
System.out.println(bd1.divide(bd2)); // 输出1.5（精确小数）
```