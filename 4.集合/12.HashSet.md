# 1 HashSet

> - 【HashSet】集合底层采取**哈希表**存储数据
> - 哈希表是一种对于增删改查数据性能都较好的结构

## 1.1 特点

> 能保证元素的唯一性。

声明字符串【HashSet】，存入重复数据：

![image-20240820195043407](assets/image-20240820195043407.png)

如果存入自定义的对象如【Student】，存入重复数据：

![image-20240820195701905](assets/image-20240820195701905.png)

发现并没有去重。为什么自定义的类没有去重呢？结合【new】关键字，很容易想到，这里比较的应该是对象地址值，如果要比较对象内容，那么就需要重写【equals()】。

使用idea快捷方式重写，它同时还生成了【hashCode()】，先将【hashCode()】注释起来，只保留【equals()】：

![image-20240820200218906](assets/image-20240820200218906.png)

再次执行：

![image-20240820195956827](assets/image-20240820195956827.png)

依然没有去重，那么放开【hashCode()】：

![image-20240820200256573](assets/image-20240820200256573.png)

再次执行：

![image-20240820200316312](assets/image-20240820200316312.png)

成功去重。

如果只保留【hashCode()】：

![image-20240820200357729](assets/image-20240820200357729.png)

也无法去重。

> 【HashSet】中的元素如果需要去重，元素对象必须同时重写【equals()】和【hashCode()】。

## 1.2 equals()和hashCode()的配合流程

观察发现【hashCode()】返回一个【int】类型，现在将该方法改为：

![image-20240820201419072](assets/image-20240820201419072.png)

然后打印【equals()】的执行：

![image-20240820201525904](assets/image-20240820201525904.png)

再次执行：

![image-20240820201540070](assets/image-20240820201540070.png)

添加4个元素，【equals()】执行了6次。

下面是图解：

【HashSet】底层采用哈希表结构：

- 在JDK8以前，哈希表 = 数组 + 链表。
- 在JDK8以后，哈希表 = 数组 + 链表 + 红黑树。

先看数组 + 链表的情况，当创建一个【HashSet】，底层就有一共哈希表结构，而这个哈希表一开始就是一个数组：

![image-20240820202310758](assets/image-20240820202310758.png)

 当【HashSet】中添加元素时，就会自动调用元素对象的【hashCode()】来得到一个【int】值，这个值可以理解为数组的下标。当添加张三时，张三就调用会【hashCode()】，返回一个1，然后张三来到1号索引的位置上，但是它并不会真正的存入在数组中，而是存入在一个链表中，然后让这个链表挂在1号位置上：

![image-20240820203057595](assets/image-20240820203057595.png)

当存入李四时，李四也会调用【hashCode()】，返回1，它也来到1号位，但是发现1号位已经有元素了，那么这时就会调用【equals()】方法来比较两者，这是【equals()】第一次被调用，张三不等于李四，那么存入李四，存储在链表中：

![image-20240820203752037](assets/image-20240820203752037.png)

同理，存入王五时，也会调用【hashCode()】，返回1，来到1号位，发现有元素，与张三和李四进行比较，这是第2次和第3次调用【equals()】，比较完后，不相等，存入王五：

![image-20240820203916072](assets/image-20240820203916072.png)

然后再次存入王五，调用【hashCode()】，返回1，来到1号位，发现有3个元素，于是依次比较，一共比较3次，这是第4、5、6次调用【equals()】，当比较到王五时，发现**内容一致**，而且**位置也一样**，那么这两个对象就是相等的，就不会存储这个王五。

最终集合中一共就存入3个元素，【equals()】被调用6次。

综上，流程如下：

1. 当添加对象的时候，会先调用对象的【hashCode()】计算出一个应该存入的索引位置，查看该位置上是否存在元素。
2. 如果没有元素，那么直接存入，不会调用【equals()】。
3. 如果存在元素，那么会调用【equals()】方法比较内容。
   1. 如果返回【false】，则位置一样，内容不同，可以存入。
   2. 如果返回【true】，则位置一样，内容也一样，不能存入。

上面的演示中存在一共问题，就是【hashCode()】返回的都是1，导致没有元素都会在1号位上存储，这样数组的其他位置就会浪费掉，而且同一个位置上存储也会导致链表过长，查询效率降低。

如何避免这个问题呢？就需要根据对象的属性来返回【int】值，比如返回年龄：

![image-20240820210319973](assets/image-20240820210319973.png)

再次执行：

![image-20240820210333562](assets/image-20240820210333562.png)

【equals()】只调用了一次，因为前3个学生的年龄不同，那么他们就会存储在不同的数组位上，只有第四个学年龄与第三个相同，所以他会来到第三个学生的位置上，发现已经有第三个学生了，于是调用【equals()】比较：

![image-20240820210732832](assets/image-20240820210732832.png)

但是这样依然存在问题，如果所有学的年龄都是一样的：

![image-20240820210835162](assets/image-20240820210835162.png)

那么这些元素依然会存储在同一个数组位上，【equals()】执行了6次，所以为了避免这种情况，还得将姓名也考虑进去。但是姓名是一个字符串，如何返回一个【int】值？

【Object】是所有类的父类，也是【String】的父类，那么【String】自然继承了【hashCode()】，通过【hashCode()】来返回【int】值，【String】内部重写了【hashCode()】，以字符来计算【int】值：

![image-20240820211215602](assets/image-20240820211215602.png)

执行：

![image-20240820211232214](assets/image-20240820211232214.png)

【equals()】只执行了1次，也就是比较两个王五那里。哪怕年龄相同，姓名不一样，【hashCode()】也不一定一样。

> 重写【hashCode()】方法时，尽量将对象的所有属性都考虑进去进行计算，因为这样**哈希值相同**的**概率**才会比**较小**。

两个字符串不一样，也可能出现哈希冲突(哈希值一样)的情况：

![image-20240820212026152](assets/image-20240820212026152.png)

把所有属性都参与到计算只能是让哈希冲突的概率降低。所以才会有【equals】比较，即便哈希值一样，也就是存储的数组位置一样，也要比较内容，内容不同才会存入，否则不会存入。

使用快捷键生成的【hashCode()】就将所以属性都考虑进行计算：

![image-20240820212422638](assets/image-20240820212422638.png)

