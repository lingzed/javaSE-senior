# 泛型

> JDK5引入的，可以在编译阶段约束操作的数据类型，并进行检查。

## 好处

> 统一数据类型，将运行期的错误提升到编译期。

比如创建一个【ArrayList】，它需要指定一个泛型：

![image-20240814161543088](assets/image-20240814161543088.png)

【E】就是根据泛型进行匹配，泛型是什么类型，【E】就是什么类型，在【add()】中就能体现：

指定为字符串，那么【add()】就接收字符串类型：

![image-20240814161824866](assets/image-20240814161824866.png)

指定为整型，就接收整型：

![image-20240814161912124](assets/image-20240814161912124.png)

如果不指定泛型，那么默认接收【Object】：

![image-20240814162016968](assets/image-20240814162016968.png)

泛型如何将错误提升到编译期？比如创建一个集合：

![image-20240814162614704](assets/image-20240814162614704.png)

再创建一个迭代器，但不指定泛型：

![image-20240814162656696](assets/image-20240814162656696.png)

那么【next()】返回的就是【Object】类型的：

![image-20240814162739967](assets/image-20240814162739967.png)

遍历出的元素是字符串，调用字符串的方法：

![image-20240814162828826](assets/image-20240814162828826.png)

报错了，因为多态编译时看左边，父类【Object】中没有该方法，所以需要向下转型：

![image-20240814162947907](assets/image-20240814162947907.png)

当前集合中存储的是字符串，如果再存储整型，那么就不能指定泛型：

![image-20240814163129648](assets/image-20240814163129648.png)

但是运行就会报错，因为向下转型会失败：

![image-20240814163247959](assets/image-20240814163247959.png)

但是一点加上了泛型，那么在编译阶段就提示不能添加整型：

![image-20240814163357065](assets/image-20240814163357065.png)

从而避免错误的发生，这就是将运行期的错误提升到编译期。