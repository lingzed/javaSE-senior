# 泛型

> JDK5引入的，可以在编译阶段约束操作的数据类型，并进行检查。

## 好处

> 统一数据类型，将运行期的错误提升到编译期。

比如创建一个`ArrayList`，它需要指定一个泛型：

![image-20240814161543088](assets/image-20240814161543088.png)

`E`就是根据泛型进行匹配，泛型是什么类型，`E`就是什么类型，在`add()`中就能体现：

指定为字符串，那么`add()`就接收字符串类型：

![image-20240814161824866](assets/image-20240814161824866.png)

指定为整型，就接收整型：

![image-20240814161912124](assets/image-20240814161912124.png)

如果不指定泛型，那么默认接收`Object`：

![image-20240814162016968](assets/image-20240814162016968.png)

泛型如何将错误提升到编译期？比如创建一个集合：

![image-20240814162614704](assets/image-20240814162614704.png)

再创建一个迭代器，但不指定泛型：

![image-20240814162656696](assets/image-20240814162656696.png)

那么`next()`返回的就是`Object`类型的：

![image-20240814162739967](assets/image-20240814162739967.png)

遍历出的元素是字符串，调用字符串的方法：

![image-20240814162828826](assets/image-20240814162828826.png)

报错了，因为多态编译时看左边，父类`Object`中没有该方法，所以需要向下转型：

![image-20240814162947907](assets/image-20240814162947907.png)

当前集合中存储的是字符串，如果再存储整型，那么就不能指定泛型：

![image-20240814163129648](assets/image-20240814163129648.png)

但是运行就会报错，因为向下转型会失败：

![image-20240814163247959](assets/image-20240814163247959.png)

但是一点加上了泛型，那么在编译阶段就提示不能添加整型：

![image-20240814163357065](assets/image-20240814163357065.png)

从而避免错误的发生，这就是将运行期的错误提升到编译期。



# 泛型标识符

泛型符号只要保证合法，就可以随意指定：

![image-20240814185331167](assets/image-20240814185331167.png)

![image-20240814185355875](assets/image-20240814185355875.png)

为了见名知意，通常会将符号定义为这些：

- `E`：即element，表示元素。
- `T`：即type，表示类型。
- `K`：即key，表示建，常见于`Map`类型中。
- `V`：即value，表示值，常见于`Map`类型中。



# 泛型重点

学习泛型的重点，就是要清楚，**不同的泛型在什么时机确定类型**。



# 泛型类

在类上加入泛型：

![image-20240814190216411](assets/image-20240814190216411.png)

`name`属性可以确定为`String`类型，但是有一些变量没办法在一开始就确定类型，那么可以将该变量的类型声明为泛型：

![image-20240814190337228](assets/image-20240814190337228.png)

在创建对象时，指定为什么类型，这个变量就是什么类型：

![image-20240814190516012](assets/image-20240814190516012.png)

![image-20240814190538222](assets/image-20240814190538222.png)

## 类型确认时机

>  泛型类的泛型在创建对象的时候确认类型。

在创建泛型类对象时，需要在`<>`中指定类型，这个时刻就确定了泛型的类型。泛型类中的泛型变量，通过上面的代码可以发现，泛型变量的类型来自于泛型类，也就是说在确定泛型类的类型的时候同时也确定了泛型变量的类型。

## 注意

- 泛型只能声明非静态变量，声明静态变量无效。
- 由于泛型变量的类型来自于泛型类，所以变量定义了泛型，那么类也要定义泛型。



# 泛型方法

泛型可以声明静态和实例方法，两者的声明方式不同，确认类型的时机也不同。

## 泛型实例方法

其实上面的代码已经演示过了，实例方法形参的类型声明为泛型，这就是一个泛型实例方法：

![image-20240814192454580](assets/image-20240814192454580.png)

### 类型确认时机

> 泛型类实例化的时候确认，即来至泛型类的类型。

## 泛型静态方法

泛型实例方法的类型来自于泛型类的类型，但是静态方法存在的时候，对象不一定存在，所以泛型静态方法的类型不能从泛型类那里获取，而是由它自己定义，它需要在`static`后面写一个`<>`来定义泛型：

![image-20240814193101086](assets/image-20240814193101086.png)

### 类型确认时机

> 泛型静态方法的类型在该方法被调用时确认，类型来自于传入的参数类型。

![image-20240814193452923](assets/image-20240814193452923.png)

案例：假设有一个方法，打印数组：

![image-20240814193955452](assets/image-20240814193955452.png)

定义三个不同类型的数组，分别传入该方法：

![image-20240814193945807](assets/image-20240814193945807.png)

由于方法的形参为`String[]`，所以只能接收字符串数组，这样的方法不够灵活，如果想让该方法接收更多类型的数组，那么可以将其定义为泛型方法：

![image-20240814194115824](assets/image-20240814194115824.png)

这样就能接收不同类型的数组：

![image-20240814194201731](assets/image-20240814194201731.png)

## 多泛型

如果一个方法不知一个泛型参数，那么声明了多少泛型的参数，在`<>`就要声明多少的泛型，中间用`,`分隔：

泛型实例方法：

![image-20240814194526994](assets/image-20240814194526994.png)

在创建对象时：

![image-20240814194639312](assets/image-20240814194639312.png)

泛型静态方法：

![image-20240814194833949](assets/image-20240814194833949.png)

在调用方法时：

![image-20240814195012464](assets/image-20240814195012464.png)

# 注意

> 泛型只能编写引用数据类型。

方法接收泛型数组：

![image-20240814195538381](assets/image-20240814195538381.png)

定义数组，但是基本数据类型的数组无法传入方法中：

![image-20240814195609052](assets/image-20240814195609052.png)

因为泛型只能编写引用数据类型。



# 泛型接口

在接口上声明泛型：

![image-20240814195853486](assets/image-20240814195853486.png)

## 类型确认时机

> 泛型接口的类型确认时机由两种：
>
> 1. 在实现类实现接口的时候，由实现类指定泛型类型。
> 2. 在实现类实现接口的时候，实现类也声明泛型，在创建实现类对象时确认实现类泛型类型，接口沿用该类型。

第一种情况：

![image-20240814200253164](assets/image-20240814200253164.png)

第二种情况，如果实现类也不知到声明接口的为什么类型，那么它自己也可以声明泛型，由调用者来确认。

![image-20240814200438371](assets/image-20240814200438371.png)

第二种情况，在集合继承和实现体系中比较常见：

`ArrayList`中：

![image-20240814200607006](assets/image-20240814200607006.png)

`List`中：

![image-20240814200650975](assets/image-20240814200650975.png)



# 泛型通配符

代码材料：

员工类：

![image-20240814201350719](assets/image-20240814201350719.png)

程序员类和经理类：

![image-20240814201816166](assets/image-20240814201816166.png)

创建两个集合：

![image-20240814201953989](assets/image-20240814201953989.png)

定义一个方法，遍历集合：

![image-20240814202135744](assets/image-20240814202135744.png)

## ?

如果`print()`中的集合类型是`Coder`，那么就不能接收`Manager`，同理，如果类型是`Manager`，那么也不能接收`Manager`。如何既能接收`Coder`也能接受`Manager`呢？这时候就需要使用泛型通配符`?`：

![image-20240814202511645](assets/image-20240814202511645.png)

`?`表示任意类型，需要注意，`?`表示任意类型，归根结底它也是一种类型，就跟`String`、`Integer`表示类型一样，不能将`?`与泛型搞混淆，泛型是不知道该声明什么类型就用一个泛型符合去占位，而`?`是去填充这个位置的，就像`String`去填充`<>`表示`String`类型，而`?`去填充`<>`表示任意类型。

用了`?`后，泛型的类型就是`Object`：

![image-20240814203434737](assets/image-20240814203434737.png)

调用`work()`需要向下转型，如果要同时满足`Coder`和`Manager`，那么就转型为`Employee`：

![image-20240814203556777](assets/image-20240814203556777.png)

## ? extends 类型

但是这样的方法存在隐患，`?`最终会被转换为`Object`类型，也就是说任何类型的`ArrayList`都能传入这个方法，那么非`Employee`继承体系的`ArrayList`进入，就会发生类型转换异常：

![image-20240814211045950](assets/image-20240814211045950.png)

那么就需要将类型限定为`Employee`继承体系的类，可以使用另一个通配符：`? extends 类型`。

> `? extends 类型`表示泛型的类型为指定类型及其子类。

![image-20240814212029985](assets/image-20240814212029985.png)

`? extends Employee`，表示`ArrayList`只接收`Employee`及其子类：

![image-20240814212130447](assets/image-20240814212130447.png)

## ? super 类型

> 表示泛型的类型为指定类型及其父类。

与`? extends 类型`反过来：

![image-20240814213133423](assets/image-20240814213133423.png)

![image-20240814213258859](assets/image-20240814213258859.png)