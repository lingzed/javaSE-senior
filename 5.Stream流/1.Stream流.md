# 1 Stream流

> 配合【lambda】表达式，简化集合和数组的操作。

案例：

1、创建一个集合，存储多个字符串元素：

```java
"张无忌";
"张良";
"王二麻子";
"谢广坤";
"张三丰";
"张翠山";
```

2、把集合中所有以"张"开头的元素存储到一个新的集合。

3、把"张"开头的集合中的长度为3的元素存储到一个新的集合。

4、遍历上一步得到的集合中的元素输出。

![image-20240826191354285](assets/image-20240826191354285.png)

换成【Stream】流，首先调用【Stream()】，将集合中的元素放入【Stream】流中：

![image-20240826191840140](assets/image-20240826191840140.png)

然后调用【filter()】过滤掉流中的数据，满足条件的保留，不满足过滤，首先过滤掉不是张开头的元素：

![image-20240826192024996](assets/image-20240826192024996.png)

在上一步的基础上。再过滤掉长度不为3的元素：

![image-20240826192134799](assets/image-20240826192134799.png)

然后调用【forEach()】遍历：

![image-20240826192207666](assets/image-20240826192207666.png)

结果：

![image-20240826192245195](assets/image-20240826192245195.png)

【Stream】流用到的思想是流水线操作，将原材料放到流水线进行一系列的加工，最终变成一个成品。而【Stream】流操作的原材料就是数据，对其进行加工的过程就在在对数据进行处理的过程，比如去重，截取，过滤等等操作，最终数据从这条流水线上下来就需要的样子。

从案例中也可看到，整个【Stream】流操作就是一条链式调用，就跟流水线链路一样。

【Stream】流的学习要点：

> 1. 如果将数据放入流中，即获取流对象。
> 2. 中间方法。
> 3. 终结方法。



# 2 获取流对象

如何将数据放入流中？即如何获取流对象？

数据放入流大致分为3种：

- 集合获取流对象。
- 数组获取流对象。
- 零散数据获取流对象。

## 2.1 单列集合获取流

```java
default Stream<E> stream(){};
```

> 【Collection】接口的默认方法，单列集合获取流。
>
> **注意**：是单列集合。

![image-20240826193531766](assets/image-20240826193531766.png)

创建了流，就意味着集合中的数据已经放到了流水线上。那么就可以使用(调用)流水线上(流对象)的工具(流对象的方法)对原材料(数据)进行加工操作。

比如调用【forEach()】，遍历元素：

![image-20240826193702209](assets/image-20240826193702209.png)

## 2.2 双列集合获取流

如法炮制：

![image-20240826194338051](assets/image-20240826194338051.png)

【Map】体系的集合无法直接获取流。

但是可以间接获取流，在【Map】篇章中说到过，【Map】底层数据结构主要针对键，因为可以通过键来获取值，而【Map】有一个方法可以获取所有的键集合，返回一个【Set】，而【Set】刚好是一个单列结合，可以直接调用【stream()】方法来获取流对象。

那么得到了键的流对象，就可以通过操作建来操作对应的值：

![image-20240826195007414](assets/image-20240826195007414.png)

但是这种方式并不推荐，因为只获取了键集合，键和值是分开的，操作不方便。

推荐使用【entrySet()】，因为它返回的是键值对集合，键和值是在一起的：

![image-20240826195521077](assets/image-20240826195521077.png)

## 2.3 数组获取流

```java
public static <T> Stream<T> stream(T[] arr){};
```

> 通过【Arrays】数组工具类的【stream()】获取流对象，传入一个数组，返回该数组的流。

![image-20240826200023949](assets/image-20240826200023949.png)

## 2.4 零散数据获取流

```java
public static <T> Stream<T> of(T ...args){};
```

> 【Stream】的静态方法，接收可变参数。

![image-20240826200623658](assets/image-20240826200623658.png)

可变参数本质是一个数组，这意味着，可以直接传入数组：

![image-20240826200730751](assets/image-20240826200730751.png)



# 3 中间方法

> 之所以叫中间方法是因为这些方法都会返回新的流，既然返回了流，就能继续调用流的方法操作下去，所以叫中间方法。

## 3.1 filter()

```java
public Stream<T> filter(Predicate<? super T> predicate){};
```

> 过滤流中的数据，满足条件的数据保留，不满足则过滤。
>
> 返回一个新的流。

【filter()】接收一个函数式接口【Predicate】作为参数：

![image-20240826201456385](assets/image-20240826201456385.png)

需要重写的【test()】返回一个布尔值。就是根据这个布尔值【filter()】来决定是否过滤掉数据。

过滤掉姓不是张的名字：

![image-20240826201820080](assets/image-20240826201820080.png)

重点是【filter()】的返回值，它返回的是一个新的流对象，依然是一个流：

![image-20240826202230933](assets/image-20240826202230933.png)

既然是流，那么就可以继续调用流方法，比如，继续过滤：

![image-20240826202400942](assets/image-20240826202400942.png)

这类方法之所以叫做中间方法，就是因为他们返回的是一个新的流，既然是流就可以继续调用方法操作下去。

## 3.2 limit()

```java
public Stream<T> limit(long maxSize){};
```

> 获取流中前几个数据，返回新的流。

![image-20240828153115981](assets/image-20240828153115981.png)

## 3.3 skip()

```java
public Stream<T> skip(long n){};
```

> 跳过流中前几个数据，返回新的流。

![image-20240828153317516](assets/image-20240828153317516.png)

## 3.4 concat()

```java
public static <T> Stream<T> concat(Stream s1, Stream s2){};
```

> 【Stream】静态方法，合并两个流，形成新的流。
>
> **注意**：此方法只接收两个流。

![image-20240828154006259](assets/image-20240828154006259.png)

## 3.5 distinct()

```java
public Stream<T> distinct(){};
```

> 去重流中的数据，返回新流。
>
> **注意**：此方法的去重依赖【hashCode()】和【equals()】。

在3.4的基础上：

![image-20240828154321203](assets/image-20240828154321203.png)

报错了，错误信息为：

![image-20240828154341469](assets/image-20240828154341469.png)

意思是：**流已经关闭**。

流水线工作，是无法回退的，原材料从流水线上下来，是不能再操作的。

在这个案例中，调用【distinct()】之前，【concatS】已经调用了【forEach()】：

![image-20240828155308922](assets/image-20240828155308922.png)

这个方法是流的终结方法，可以理解为流水线上的最后一道工序，此道工序以后，就代表原料已经从流水线上下来了，即终结方法执行完后，数据就会从流中出来，流就会关闭，既然流已经关闭，那么自然不能调用其方法，也就报了流关闭的错误。

![image-20240828155425891](assets/image-20240828155425891.png)

## 3.6 注意

> 流对象一旦被使用，就不允许再次被使用。

3.5中已经说了【forEach()】，另外【concat()】，它会合并两个流对象为一个流，这也是在使用流对象，即原来的流在合并之后就不能再被使用：

![image-20240828155919580](assets/image-20240828155919580.png)



# 4 终结方法

> 流水线中的最后一道工序。这类方法返回的不再是流，所以叫做终结方法。
>
> **注意**：终结方法会关闭流。

## 4.1 forEach()

```java
public void forEach(Consumer action){};
```

> 遍历流中数据。

![image-20240828160740059](assets/image-20240828160740059.png)

## 4.2 count()

```java
public long count(){};
```

> 统计流中数据个数。

![image-20240828161046602](assets/image-20240828161046602.png)



# 5 收集流

> 即将【Stream】操作后的数据再收集到集合中。

在【Stream】中对数据进行操作时，是不会修改数据源的，因此需要收集操作，将操作后的数据收集形成新数据集。