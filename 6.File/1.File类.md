# 1 File类

> 在java中，`File`表示**文件**和**文件夹**。

## 1.1 File的构造

构造一：

```java
public File(String pathname){};
```

> 根据文件路径创建文件对象。

关联D盘下的文件：

![image-20240829163207547](assets/image-20240829163207547.png)

此时，D盘下没有该文件，但是执行不会报错：

![image-20240829163348160](assets/image-20240829163348160.png)

> `File`类关联文件和文件夹，即使文件和文件夹不存在也不会报错，因为`File`提供了创建文件和文件夹的方法。

构造二：

```java
public File(String parent, String child){};
```

> 根据父级路径和子级路径封装`File`对象。

![image-20240829164243997](assets/image-20240829164243997.png)

构造三：

```java
public File(File parent, String child){};
```

> 根据父级`File`对象和子级路径封装成`File`。

![image-20240829164614830](assets/image-20240829164614830.png)

## 1.2 相对路径和绝对路径

> **绝对路径**：从盘符根目录开始，一直到某个具体的文件或文件夹。

比如：

![image-20240829165025376](assets/image-20240829165025376.png)

从根目录D盘开始，到具体的Download目录，简单来说就是路径写全。

> **相对路径**：若在idea中，则相对于当前项目。

![image-20240829165336622](assets/image-20240829165336622.png)

调用`getAbsolutePath()`获取绝对路径，打印出的路径是项目路径：

![image-20240829165409609](assets/image-20240829165409609.png)

可见，当前项目中封装的相对路径是相对于项目的。

相对路径创建文件，文件存在项目路径下：

![image-20240829170801097](assets/image-20240829170801097.png)

如果想让文件创建在当前目录下：

![image-20240829195920174](assets/image-20240829195920174.png)

而目录又在当前项目下，因此可以用相对路径省略项目路径部分：

![image-20240829200101495](assets/image-20240829200101495.png)

![image-20240829200121707](assets/image-20240829200121707.png)

除了用`\`作为分隔符，还可以用`/`，只不过`\`是转义符，需要用`\`转义，为`\\\`。

## 1.3 isDirectory()

```java
public boolean isDirectory(){};
```

> 判断此路径名表示的`File`是否为文件夹。

![image-20240829200620618](assets/image-20240829200620618.png)

## 1.4 isFile()

```java
public boolean isFile(){};
```

> 判断此路径名表示的`File`是否为文件。

![image-20240829200709452](assets/image-20240829200709452.png)

## 1.5 exists()

```java
public boolean isFile(){};
```

> 判断文件或文件夹是否存在。

![image-20240829200855580](assets/image-20240829200855580.png)

## 1.6 length()

```java
public long length(){};
```

> 返回文件的大小(字节数量)。

![image-20240829201314737](assets/image-20240829201314737.png)

**注意**：此方法计算文件夹的字节数是错误的，这是该API设计的问题：

![image-20240829201800190](assets/image-20240829201800190.png)

实际大小：

![image-20240829201824058](assets/image-20240829201824058.png)

## 1.7 getAbsolutePath()

```java
public String getAbsolutePath(){};
```

> 返回文件或文件夹的绝对路径。

![image-20240829202155188](assets/image-20240829202155188.png)

## 1.8 getPath()

```java
public String getPath(){};
```

> 返回定义文件对象时使用的路径，也就是构造方法中指定的路径。

![image-20240829202546792](assets/image-20240829202546792.png)

## 1.9 getName()

```java
public String getName(){};
```

> 返回文件或文件夹的名称，带后缀。

![image-20240829202808108](assets/image-20240829202808108.png)

## 1.10 lastModified()

```java
public long lastModified(){};
```

> 返回文件或文件夹最后修改时间，返回毫秒值。

![image-20240829203230331](assets/image-20240829203230331.png)

如果文件或文件夹不存在，则返回0。



## 1.11 案例

键盘录入一个文件夹路径，如果输入错误就给出提示，并继续录入，直到正确为止。

文件夹路径不存在或路径为文件路径均为错误路径。

![image-20240829204747230](assets/image-20240829204747230.png)

改进，封装为方法：

![image-20240829210343330](assets/image-20240829210343330.png)



# 2 创建/删除

## 2.1 creatNewFile()

```java
public boolean creatNewFile(){};
```

> 创建一个新的空文件，创建成功返回`true`，反之返回`false`。

带后缀和不带后缀的文件都能创建：

![image-20240829210834194](assets/image-20240829210834194.png)

若文件已存在，则创建失败：

![image-20240829210915239](assets/image-20240829210915239.png)

## 2.2 mkdir()

```java
public boolean mkdir(){};
```

> 创建文件夹，只能创建1级文件夹，创建成功返回`true`，反之返回`false`。

![image-20240829211319768](assets/image-20240829211319768.png)

此案例中尝试用文件名来创建文件夹，最终创建了文件夹，可见只要名称合法就会被理解为创建文件夹，.显然是一个合法名。

**同时也说明，创建文件还是文件夹，并不看名称，而是看调用什么方法。**

若文件存在，则创建失败：

![image-20240829211404166](assets/image-20240829211404166.png)

若尝试创建多级文件夹，则创建失败，毕竟此方法只能创建1级文件夹：

![image-20240829212316152](assets/image-20240829212316152.png)

## 2.3 mkdirs()

```java
public boolean mkdirs(){};
```

> 创建文件夹，能创建多级文件夹，创建成功返回`true`，反之返回`false`。

![image-20240829212508182](assets/image-20240829212508182.png)

## 2.4 delete()

```java
public boolean delete(){};
```

> 删除文件或文件夹，删除成功返回`true`，反之返回`false`。
>
> **注意**：`delete()`只能删除空文件夹，若文件夹中有文件或文件夹，则不能删除。
>
> **慎重：`delete()`删除的文件或文件夹不会去回收站，故不能撤回！！！**

删除前：

![image-20240829212649368](assets/image-20240829212649368.png)

删除后：

![image-20240829212721151](assets/image-20240829212721151.png)

`delete()`只能删除空文件夹，若文件夹中有文件或文件夹，则不能删除：

![image-20240829213042715](assets/image-20240829213042715.png)

删除文件：

![image-20240829213203003](assets/image-20240829213203003.png)

![image-20240829213217983](assets/image-20240829213217983.png)



# 3 遍历方法

## 3.1 listFiles()

```java
public File[] listFiles(){};
```

> 获取当前目录下所有的**1级文件对象**返回`File`数组。

如何理解1级文件对象？举个例子，在当前目录下：

![image-20240830194301597](assets/image-20240830194301597.png)

如果使用`listFiles()`，那么只会将aaa、A.txt、B.txt封装到`File[]`中去，aaa文件夹中的子文件不会封装到数组中。像aaa、A.txt、B.txt这种**在当前文件夹下**就是1级文件对象，而aaa里面的子文件对象就不是1级文件对象。

![image-20240830194814264](assets/image-20240830194814264.png)

aaa中的子文件对象并没有封装到数组中，也就没有打印出来。

## 3.2 案例

键盘录入文件夹路径，找出目录下所有.java文件。

![image-20240830200452176](assets/image-20240830200452176.png)

判断文件的后缀名是否为.java文件即可。重点是忽略文件夹，如果当前的对象是文件夹，那么截取的文件对象名称不一定有.，这块容易报错。

如果不只是找出当前目录下的.java文件，还有找出子文件夹下面的.java文件该怎么办呢？这就需要用到递归思想了，对文件夹进行递，当遇到文件就停止，往前归。

aaa目录：

![image-20240830201417013](assets/image-20240830201417013.png)

bbb目录：

![image-20240830201432246](assets/image-20240830201432246.png)

使用递归完成文件夹遍历：

![image-20240830201709229](assets/image-20240830201709229.png)

`endsWith()`，判断是否以传入的字符串为后缀。

## 3.3 注意

如果遍历D盘：

![image-20240830202551100](assets/image-20240830202551100.png)

报错了，显示空指针。最终错误指向16行：

![image-20240830202645885](assets/image-20240830202645885.png)

分析得出`File[]`数组有可能为`null`。这其实是调用`listFiles()`的一个注意实事项：

> - 当调用者`File`表示的**路径不存在**时，返回`null`。
> - 当调用者`File`表示的**路径是文件**时，返回`null`。
> - 当调用者`File`表示的**路径是一个空文件夹**时，返回一个长度为0的数组。
> - 当调用者`File`表示的路径是**需要权限才能访问**的文件夹时，返回`null`。

所以，原因就是D盘中存在需要权限才能访问的文件夹，因此访问此文件夹时`listFiles()`返回了一个空数组，，导致报错。

![image-20240830203353194](assets/image-20240830203353194.png)

解决方法就是加非空判断：

![image-20240830203826921](assets/image-20240830203826921.png)

## 3.4 自定义删除文件

使用递归删除文件夹下所有文件夹：

![image-20240830211009843](assets/image-20240830211009843.png)

删除后，只删除了文件，没有删除文件夹：

![image-20240830211155665](assets/image-20240830211155665.png)

![image-20240830211208936](assets/image-20240830211208936.png)

![image-20240830211226637](assets/image-20240830211226637.png)

只需在循环遍历后，再执行一次删除即可：

![image-20240830211341991](assets/image-20240830211341991.png)

现在连test-副本都删除了：

![image-20240830211419163](assets/image-20240830211419163.png)

因为循环遍历中只是递归删除了文件，所以出了循环意味着该目录下的所有文件都以删除，该目录变成了空目录，可以直接删除。

## 3.5 统计文件夹大小

递归统计文件夹大小：

![image-20240830212602129](assets/image-20240830212602129.png)

![image-20240830212619929](assets/image-20240830212619929.png)

## 3.6 统计文件类型个数

![image-20240830222658827](assets/image-20240830222658827.png)

用递归统计，用`Map`来存放：

![image-20240830222725110](assets/image-20240830222725110.png)

**注意**：文件即使没有后缀后也是可以存在的，只是文件类型未知。另外获取后缀名时，从最后一个.开始，因为文名中允许存在.。