# 一、 InterruptedException

当我调用`sleep()`时会抛出`InterruptedException`异常，这个异常表示什么意思呢？它表示线程在执行阻塞任务的时候，被其他线程中断导致提前终止阻塞状态时抛出的异常。

也就是说，只有那些导致线程进入**阻塞等待**状态的方法，在被中断时才会抛出 `InterruptedException`。

`sleep()`是一个阻塞方法，所以它会抛出这个异常。

其他会抛出此异常的方法还有：

| 方法名                                              | 所属类/接口                              | 说明                             |
| --------------------------------------------------- | ---------------------------------------- | -------------------------------- |
| `Thread.sleep(long millis)`                         | `java.lang.Thread`                       | 让当前线程休眠指定毫秒数         |
| `Object.wait()`                                     | `java.lang.Object`                       | 当前线程等待，直到被唤醒         |
| `Object.wait(long timeout)`                         | `java.lang.Object`                       | 等待指定时间或被唤醒             |
| `Thread.join()`                                     | `java.lang.Thread`                       | 等待线程终止                     |
| `Thread.join(long millis)`                          | `java.lang.Thread`                       | 等待线程指定时间内终止           |
| `BlockingQueue.take()`                              | `java.util.concurrent.BlockingQueue`     | 从队列中获取元素，队列为空时阻塞 |
| `BlockingQueue.put(E e)`                            | `java.util.concurrent.BlockingQueue`     | 向队列中放元素，队列满时阻塞     |
| `CountDownLatch.await()`                            | `java.util.concurrent.CountDownLatch`    | 等待计数器归零                   |
| `CountDownLatch.await(long timeout, TimeUnit unit)` | `java.util.concurrent.CountDownLatch`    | 超时等待计数器归零               |
| `Semaphore.acquire()`                               | `java.util.concurrent.Semaphore`         | 获取许可，若无许可则阻塞         |
| `Semaphore.acquire(long permits)`                   | `java.util.concurrent.Semaphore`         | 获取多个许可，若无许可则阻塞     |
| `Exchanger.exchange(V x)`                           | `java.util.concurrent.Exchanger`         | 线程间交换数据，等待对方线程     |
| `Future.get()`                                      | `java.util.concurrent.Future`            | 等待异步任务完成                 |
| `LockSupport.park()`                                | `java.util.concurrent.locks.LockSupport` | 阻塞当前线程                     |

## 1.1 为什么要中断？

你有没有想过，为什么要让别的线程中断正在 sleep() 的线程？或者更具体一点，为什么要中断阻塞的线程，中断它干嘛？谁要打扰它？

原因是因为 **中断是线程间的一种"协作式通信机制"**，用于让线程“停止当前正在做的事情（比如 sleep、等待、阻塞），尽快响应退出、重试、切换状态等操作”。

**场景 1：程序需要尽快关闭（优雅退出）**

你有个线程正在休眠或执行耗时操作，但此时用户点击了**退出**，主线程希望所有子线程立刻终止。

```java
Thread worker = new Thread(() -> {
    while (!Thread.currentThread().isInterrupted()) {
        try {
            // 模拟耗时操作
            System.out.println("做任务中...");
            Thread.sleep(10000); // 睡 10 秒
        } catch (InterruptedException e) {
            System.out.println("被中断了，准备退出...");
            Thread.currentThread().interrupt(); // 恢复中断状态
        }
    }
});

worker.start();

// 模拟2秒后用户点击退出
Thread.sleep(2000);
worker.interrupt(); // 中断正在做任务的线程
```

如果不中断，它会继续 sleep 8 秒，退出太慢。

**场景 2：超时控制**

又比如，假设你有个线程在等某个资源，但你不想它等太久。你开一个"看门狗线程"，在超时后中断它。

```java
Thread taskThread = ...;

Thread timeoutWatcher = new Thread(() -> {
    try {
        Thread.sleep(5000);
        taskThread.interrupt(); // 5 秒还没完成，中断它
    } catch (InterruptedException ignored) {}
});
timeoutWatcher.start();
```

**场景 3：取消长任务（协作式取消）**

再比如，某些任务执行时间很长，比如文件扫描、视频转码。你希望用户在点击“取消”按钮时能中止任务。

```java
public class ScanTask implements Runnable {
    public void run() {
        // 判断是否中断
        while (!Thread.currentThread().isInterrupted()) {
            // 没有。那么做一点事情
            doSome();
            // 有被中断，则退出循环
            if (Thread.currentThread().isInterrupted()) {
                break;
            }
        }
    }
}
```

这里判断是否中断的逻辑。需要我们自己来写，而不是自动中断的。

**场景 4：线程池中的任务被主动取消**

还有就是，线程池中有超时任务或被管理员取消的任务，会通过 `Future.cancel(true)` 中断执行线程。

```java
Future<?> future = executor.submit(() -> {
    Thread.sleep(10000); // 假设任务很久
});

Thread.sleep(2000);
future.cancel(true); // 会触发线程中断
```

## 1.2 中断就中断，为什么要抛异常？

因为在 **阻塞操作（如 `sleep()`、`wait()`、`join()`）中，如果线程被中断，抛异常是最直接、最醒目的通知方式**，换句话说，抛出异常就是我上面说的**"协作式通信机制"**的实现。我抛出异常，相当于我给到了你通知：你当前的这个线程被中断了，你在`catch()`中的处理即为对线程中断的处理，你可以选择在`catch()`做中断后的事情，也可以选择什么都不管。

举个例子：

```java
public class MyWorker implements Runnable {
    @Override
    public void run() {
        try {
            while (true) {
                System.out.println("干活中...");
                Thread.sleep(5000); // 休息一下
            }
        } catch (InterruptedException e) {
            System.out.println("我被中断了！准备收工");
            // 可选择做一些清理动作
        }
        System.out.println("线程退出");
    }
}


Thread t = new Thread(new MyWorker());
t.start();

// 2秒后中断
Thread.sleep(2000);
t.interrupt(); // 发起中断请求
```

在这段代码中，我们的线程正在进行耗时操作，耗时5s，而在主线程中，过了2s后中断了这个线程，实际上是发出了一个通知，而线程被中断就会抛出异常，用`catch`捕获这个异常，实际上就是捕获到了这个通知，捕获到这个通知后，我就可以做某些事情了，这就是**"协作式通信机制"**的实现。

而且抛出一个具体的中断异常`InterruptedException`，你就知道这是一个来自中断的通知，那么你就能针对性的进行处理。

## 1.3 中断≠终止线程

**中断 interrupt() 并不会强制“停止”线程，而是给线程发出一个“请求你停下来”的通知**。

这是一个很大的误区，实际上中断并不会终止线程的执行，而是给线程发出一个请求停下来的通知。其实上面的说的抛异常实现协助通信机制已经侧面应征了这一点。

我们在这里发起中断：

```java
t.interrupt(); // 发起中断请求
```

实际是发起了中断的请求，线程中用抛异常来响应这个请求。其实仔细想想看，就会发现，如果中断真的能终止线程，那么线程到这一步就直接死掉了，哪还会抛出异常，执行后续操作？

## 1.4 既然不是终止线程，那么中断的意义是什么？

不是强制停止，那这个中断还有什么用？我为啥不用 `stop()` 直接停它？

 `Thread.stop()` 能强制停，但你会付出代价：

- 它会**直接把线程杀掉，不给你清理资源的机会**
- 如果线程持有锁，可能**导致死锁**
- 如果线程在处理业务，可能**导致业务状态不一致**
- 所以 Java 已经把它标为 **废弃方法（Deprecated）**

这个中断机制看起来像“废物”，但其实是 Java 在 **多线程安全性、资源一致性和系统健壮性之间折中的最优解**。

### 1.4.1 中断的意义是什么？

> **它是一个“线程之间友好协作”的信号机制，避免暴力终止带来的问题**。

说人话就是：

我(A线程)调用中断，通知你(B线程)我不想让你干了，你有空停一下？

如果你愿意响应这个通知，你可以：

- **安全退出**
- **释放资源**
- **保存状态**
- **做收尾工作**
- **不搞崩系统**

### 1.4.2 那为什么 Java 不提供一个“安全的强制停止”？

因为这东西**本质上不存在**：

- 你根本不知道一个线程此时正在干什么
- 你贸然终止它，可能会留下数据库事务、文件句柄、加锁状态
- 所以 Java 设计者干脆说：**那你就老老实实写“怎么停”的逻辑吧**

这个设计哲学就是：**我不干涉你线程怎么写，我只提供信号 —— 中断，真正的退出逻辑要你自己决定，因为你最清楚你的线程在干什么，怎么收场最安全**。

## 1.5 `Thread.currentThread().interrupt();` 是干什么的？

我们处理`InterruptedException`异常时，通常会执行这样的语句：

```java
Thread.currentThread().interrupt();
```

那么它的作用是什么呢？

它的作用就是：**用来“重新设置当前线程的中断状态”为 `true`，表示“我仍然记得我被中断过”。**

### 1.5.1 为啥需要这一步？

当你调用以下这些**会抛出 `InterruptedException` 的阻塞方法**时：

```java
Thread.sleep()
Object.wait()
Thread.join()
BlockingQueue.take()
```

如果线程在阻塞过程中被中断，会发生两件事：

- 抛出 `InterruptedException`

- **中断状态会被自动清除（即设为 `false`）！⚠️**

所以你 catch 之后就“忘了被中断这回事”！

```java
try {
    Thread.sleep(5000);
} catch (InterruptedException e) {
    // 到这一步，线程的中断状态已经变成 false 了！
}
```

那怎么办？我还想“保留中断信息”怎么办？

这时就用：

```java
Thread.currentThread().interrupt(); // 重新设置中断标志为 true
```

这就是一个**“中断状态的恢复动作”**，目的是：

> 告诉调用者/上层逻辑：我被中断过，虽然我处理了异常，但我没忘！你还可以根据这个状态决定是否继续中断。

### 1.5.2 中断状态

> 中断状态是线程内部的一个标志位，用来表示：**“你是否被中断过”**。

相关方法：

| 方法                     | 作用                       | 是否清除状态     |
| ------------------------ | -------------------------- | ---------------- |
| `thread.interrupt()`     | 设置中断状态为 `true`      | 否               |
| `thread.isInterrupted()` | 查看某线程是否被中断       | 否               |
| `Thread.interrupted()`   | 查看**当前线程**是否被中断 | ✅ 是，会清除状态 |

为什么中断状态会被自动清除？

因为调用了某些**会抛出 `InterruptedException` 的阻塞方法**：

```java
Thread.sleep()
Object.wait()
Thread.join()
BlockingQueue.take()
```

这些方法的设计是这样的：

> 一旦抛出 `InterruptedException`，就说明线程“已经处理了中断信号”，**JVM 会自动清除中断状态**，防止你误以为还需要继续处理。

那如果我不希望状态被清除怎么办？

那你在 `catch` 块里**恢复**它：

```java
catch (InterruptedException e) {
    // 让后续代码知道我被中断了
    Thread.currentThread().interrupt(); 
}
```

### 1.5.3 中断状态变成 `false`会怎么样

在 Java 的线程中断机制中，如果你不手动恢复中断状态，那么后续调用 `Thread.currentThread().isInterrupted()` 时返回的就是 `false`，线程会**误以为“没有人中断我”，然后继续正常运行**。

来看一个例子：

```java
public class Demo {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(3000); // 阻塞点
                } catch (InterruptedException e) {
                    // 没恢复中断标志
                    System.out.println("被中断了，但我没记住！");
                }

                // 检查是否被中断
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("我记得我被中断了，准备退出");
                    break;
                }
            }
        });

        t.start();

        Thread.sleep(1000);
        t.interrupt(); // 中断线程
    }
}
```

主线程1s后中断线程，然后线程并没有手动恢复中断状态。那么最终`if (Thread.currentThread().isInterrupted())`就不会成立，也就是不会终止当前的循环。

如果我们想要终止线程该怎么办，用中断方法并不会终止线程，它会导致JVM清除线程的中断标记，我们需要结合这个标记来间接的终止线程，就像上面的例子一样，我们通过判断中断状态是否已中断，来决定是否结束循环，进而影响是否终止线程，也就是说我们可以利用中断状态来达成终止线程的目的，当然不仅如此，我们还可以用它来做一些需要线程终止后执行的操作，因此如果我们不手动恢复中断状态，就会影响到这些操作。

### 1.5.4 为什么JVM要清除中断标记

为什么JVM要清除中断标记？从直觉上来看，被中断了，那么中断标记应该为`true`，搞的我要保证判断中断的正确性，还得手动恢复中断标记。

我们来回顾一下，清除的场景：**当阻塞方法（如 sleep/wait/join）抛出 `InterruptedException` 时，JVM 会自动清除中断状态标志。**

清除的原因如下：

1. **中断异常已经传递了“中断信号”，无需再留中断标志**

- 你调用了阻塞方法（如 `Thread.sleep()`），它抛出 `InterruptedException`，这就是**中断请求的明确传达**。
- JVM认为：“我已经通过异常告诉你你被中断了，还保留中断标志干啥？怕你重复处理？”

所以中断标志就被**当场清除**了。

2. **防止误判断导致逻辑混乱**

如果不清除中断状态，会发生什么？

```java
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    // 未清除中断标志，状态仍为 true
}
```

比如，一个线程中的流程是中断后处理然后重新开始运行，如果这次的标记没有被清除，那么当他下次运行再次被中断时，然后保留上一次的中断状态，这显然是不合理的。

3. **给予程序员控制权，而不是自动行为**

Java 设计哲学是：**我帮你清除了标志，你如果需要“记住”，请你自己手动恢复**：

```java
catch (InterruptedException e) {
    // 程序员主动决定是否记住
    Thread.currentThread().interrupt(); // 恢复中断标志
}
```

这样你就可以灵活地做出判断：

- ✅ 是不是要继续传递中断？
- ✅ 要不要退出线程？
- ✅ 是否进行清理操作？

### 1.5.5 有了catch捕获终止异常，并进行后续处理，那么终止状态还有什么用？

中断时，我能在`catch`块都能处理，干嘛还要判断 `Thread.currentThread().isInterrupted()` ？中断状态不是多余了吗？

比如上面的例子：

```java
while (true) {
    try {
        Thread.sleep(3000); // 阻塞点
    } catch (InterruptedException e) {
        // 没恢复中断标志
        System.out.println("被中断了，但我没记住！");
    }

    // 检查是否被中断
    if (Thread.currentThread().isInterrupted()) {
        System.out.println("我记得我被中断了，准备退出");
        break;
    }
}
```

都已经捕获到中断异常，那么就说明线程已经被中断了，那么我直接在`catch{}`中执行不就行了，何必又再通过状态判断？就像这样：

```java
while (true) {
    try {
        Thread.sleep(3000); // 阻塞点
    } catch (InterruptedException e) {
        // 没恢复中断标志
        // System.out.println("被中断了，但我没记住！");
        // 在catch中处理
        System.out.println("我记得我被中断了，准备退出");
        break;
    }

    // 检查是否被中断
    // if (Thread.currentThread().isInterrupted()) {
    //    System.out.println("我记得我被中断了，准备退出");
    //    break;
    // }
}
```

没错，在当前的场景中，判断状态确实是多余的，但并不能说中断状态是多余，用`catch{}`处理或用状态判断处理都可以，区别在于两者的使用场景。

我上面说过，只有阻塞的方法被终止时才会抛出终止异常，那么如果一个线程中没有阻塞的方法，而其他地方又调用了这个线程的终止方法，那么这个线程就不会捕获到终止异常，那么面对这样的场景，我们无法依赖`catch{}`捕获终止信号进行处理，但是我们反而可以使用终止状态，放到一个轮询里面，不断的判断状态的标记，若状态变为终止，那么我们就接收到了终止信号，进而处理相应任务。

我们再来回顾一下，清除的场景：**当阻塞方法（如 sleep/wait/join）抛出 `InterruptedException` 时，JVM 会自动清除中断状态标志。**

那么如果是非阻塞的方法，不会抛出中断异常，JVM也就不会自动清除中断状态的标志。

那么这个线程如果要感知到中断信号，就需要通过不断的轮询终止状态。

这两个特点区分两者的使用场景。