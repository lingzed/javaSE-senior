# 1 线程生命周期

线程在启动后会经理各种状态，线程被创建并启动以后，它并不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。

线程状态：

|          状态           |                时机                |
| :---------------------: | :--------------------------------: |
|        NEW(新建)        |            创建线程对象            |
|     RUNNABLE(就绪)      | `start()`调用，但没有抢到CPU执行权 |
|      BLOCKED(阻塞)      |   线程开始运行，但是没有获取到锁   |
|      WAITING(等待)      |            `wait()`调用            |
| TIMED_WAITING(计时等待) |           `sleep()`调用            |
|  TERMINATED(结束/死亡)  |       `run()`中代码执行完毕        |

细节：

- 阻塞的时机是线程开始运行，但是没有获取到🔒。注意，此处说的是线程开始执行，这说明线程已经抢到CPU执行权，它是可以执行的，只是它没有获取到🔒，所以当此线程执行到上🔒的位置时由于没有🔒，就会陷入阻塞状态。

## 1.1 周期情况图

执行资格：可以理解为抢夺CPU执行权的资格，有资格的线程才能抢占CPU执行权，否则不能。

执行权：线程执行的权力，只有抢到了CPU才有执行权，否则没有。

### 1.1.1 顺利执行

当创建一个线程对象，线程就处于新建状态：

![image-20240920162436212](assets/image-20240920162436212.png)

当调用【start()】，线程处于就绪状态，需要与其他处于就绪状态的线程抢夺CPU执行权。此时的线程有执行资格，没有执行权：

![image-20240920162812468](assets/image-20240920162812468.png)

当线程抢到CPU执行权，进入运行状态：

![image-20240920163141114](assets/image-20240920163141114.png)

在运行期间执行【run()】中的代码，如果一切正常，【run()】运行结束，线程死亡，变成垃圾：

![image-20240920163418013](assets/image-20240920163418013.png)

这种情况是最顺利的情况。

### 1.1.2 无执行权

若某个线程此时处于运行状态，但是其他线程抢到了CPU的执行权，那么该线程会回退到就绪状态：

![image-20240920163923498](assets/image-20240920163923498.png)

### 1.1.3 休眠

若某个线程在运行状态期间调用了【sleep()】，它会进入计时等待状态，时间到了，<font color=red>会回退到就绪状态</font>。

处于计时等待状态：

- 没有执行资格
- 没有执行权

![image-20240920164621299](assets/image-20240920164621299.png)

### 1.1.4 等待

若某个线程在运行状态期间调用了【wait()】，它会进入等待状态，等待无限时间，直到它被其他线程唤醒，<font color=red>之后会回退到就绪状态</font>：

处于等待状态：

- 没有执行资格
- 没有执行权

![image-20240920165733852](assets/image-20240920165733852.png)

### 1.1.5 阻塞

若线程在运行期间没有获取🔒，它会进入阻塞状态，直到持有🔒的线程释放🔒，<font color=red>之后会回退到就绪状态</font>：

处于阻塞状态：

- 没有执行资格
- 没有执行权

![image-20240920170319666](assets/image-20240920170319666.png)