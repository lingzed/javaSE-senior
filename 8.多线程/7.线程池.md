# 1 线程池

系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互。当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程，就会严重浪费系统资源。

> 将线程对象交给线程池维护，可以降低系统成本从而提升程序的性能。

在实际开发中：

<font color=red>**强制要求**</font>：线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

说明︰线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。



# 2 JDK自带的线程池

【Executors】是JDK提供的类，它提供了静态方法来创建线程池对象。

<font color=red>**强制要求**</font>：线程池不允许使用【Executors】去创建，而是通过【ThreadPoolExecutor】的方式，这样的处理方式可以更加明确线程池的运行规则，规避资源耗尽的风险。

以下【Executors】创建线程池的方式仅做了解。

## 2.1 newCachedThreadPool()

```java
public static ExecutorServer newCachedThreadPool(){};
```

> 创建一个默认的线程池。

![image-20240920201026671](assets/image-20240920201026671.png)

### 2.1.1 submit()

```java
public Future submit(Runnable run){};
```

> 往线程池中提交一个任务，返回一个【Future】对象。

线程池创建好后，内部只是线程对象。要执行任务，需要为线程对象提交用于执行的任务，传入的参数为【Runnable】或【Callable】：

![image-20240920201427773](assets/image-20240920201427773.png)

![image-20240920201725343](assets/image-20240920201725343.png)

当前线程名是线程池名称+线程默认名。

### 2.1.2 shutdown()

```java
public void shutdown(){};
```

> 关闭线程池。

线程池默认是不会关闭的：

![image-20240920202005354](assets/image-20240920202005354.png)

这很好理解，因为即便一个任务执行完，可能还要下一个任务要执行，需要提供给其他任务。

但是可以手动关闭：

![image-20240920202236909](assets/image-20240920202236909.png)

### 2.1.3 线程对象复用

线程对象复用现象，循环提交300个任务：

![image-20240920202946833](assets/image-20240920202946833.png)

线程对象被重复使用：

![image-20240920203008881](assets/image-20240920203008881.png)

### 2.1.4 最大线程数

![image-20240920203310859](assets/image-20240920203310859.png)

源码中返回一个【ThreadPoolExecutor】，这就是一个线程池对象。通过源码可以看到，第2个参数传入一个数字，这个就是指定线程对象的数量，【Integer.MAX_VALUE】是java中整型的最大值，有20多个亿。

不推荐使用【newCachedThreadPool()】来创建线程池，因为它创建的线程池，最大数量有20多亿，没有必要创建这么多。

## 2.2 newFixedThreadPool()

```java
public ExecutorServer newFixedThreadPool(int num){};
```

> JDK提供的另一个创建线程池的方法，可以指定最大线程数量。

![image-20240920204411886](assets/image-20240920204411886.png)

重复使用10个线程对象：

![image-20240920204431883](assets/image-20240920204431883.png)

但是这种方式创建线程池也是不推荐的，因为它内部除了指定数量，还会指定其他参数：

![image-20240920204526494](assets/image-20240920204526494.png)

这些参数是java设定死的，无法做的灵活应对复杂的项目场景。

## 2.3 弊端

用JDK提供的方法创建线程池有以下弊端：

**一、【newCachedThreadPool()】**

允许的创建线程数量为【Integer.MAX_VALUE】，可能会创建大量的线程，从而导致OOM(内存溢出异常)。

**二、【FixedThreadPool】和【SignalThreadPool】**

允许的请求队列长度为【Integer.MAX VALUE】，可能会堆积大量的请求，从而导致 OOM。