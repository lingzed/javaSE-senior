# 1 单列模式

即单实例，保证该对象实例在内存中只有一份。

使用场景：

如果创建一个对象需要消耗的资源过多，比如I/O与数据库的连接，并且这个对象完全是可以复用的，就可以考虑将其设计为单例的对象



# 2 饿汉式

第一步，私有构造：

![image-20240921143525327](assets/image-20240921143525327.png)

私有构造保证其他类中无法通过`new`来创建对象。

第二步，内部创建对象，用一个变量接受：

![image-20240921143634807](assets/image-20240921143634807.png)

由于私有了构造，其他类无法创建对象，只能自身内部创建。为了防止其他类访问该变量，将属性私有。

第三步，提供一个方法返回这个对象：

![image-20240921143841274](assets/image-20240921143841274.png)

因为无法创建该类的实例，所以这个方法不能是成员方法，必须是静态方法，而静态方法无法访问成员变量，所以，变量也必须静态：

![image-20240921144102508](assets/image-20240921144102508.png)

用两个变量接受，比较地址值：

![image-20240921144550116](assets/image-20240921144550116.png)

为`true`表示指向同一个对象。

以上就是饿汉式单列的写法，之所以叫做饿汉式，是因为该实例在类加载的时候创建。



# 3 懒汉式

第一步，私有构造：

![image-20240921145051509](assets/image-20240921145051509.png)

第二步，声明一个变量用于存储该实例，但不立即创建实例：

![image-20240921145151568](assets/image-20240921145151568.png)

第三步，声明方法，返回实例，创建该实例对象，赋值给上一步声明的变量：

![image-20240921145535448](assets/image-20240921145535448.png)

修饰为静态，提供静态访问：

![image-20240921145553125](assets/image-20240921145553125.png)

加入判断，因为每调用一次`getInstance()`，就会`new`一次对象，导致无法单列，所以：

![image-20240921145748856](assets/image-20240921145748856.png)

地址值比较：

![image-20240921152234918](assets/image-20240921152234918.png)

之所以加懒汉式，是因为只有第一次调用`getInstance()`才会创建，不像饿汉式那样，类加载就创建，创建的时机延后。

## 3.1 双检锁

上面的懒汉式写法属于基础写法，这种写法有一个弊端：在多线程环境下可能会创建多个实例。

当线程1进入方法，发现变量为`null`，它刚要`new`对象，这时另一个线程抢到执行权，注意此时第一个线程并没有创建实例，此时`i1`仍然为`null`，所以这个线程也会进入`if`，然后它`new`对象，赋值给`i1`，将这个对象返回给调用者，然后第一个线程再次执行，它会接着上次执行的地方继续执行，虽然现在`i1`不是`null`，但是这个线程上次已经进行了`if`判断，会接着`if`往下执行，那么它也会`new`一个新的对象，然后赋值给`i1`，返回给调用者。

上述的过程中，一共创建了两个对象，导致不是单一实例。

因此加锁：

![image-20240921151807517](assets/image-20240921151807517.png)

但是这样仍然不是最优解，因为一旦上🔒，其他线程就会阻塞，若多个线程之间阻塞多次，会导致效率不高。

保证同步是必须的，虽然无法避免阻塞，但是可以降低阻塞的次数，因此在同步之外再套一层判断：

![image-20240921152049272](assets/image-20240921152049272.png)

如果发现`i1`不为`null`，就没必要加🔒，直接返回即可。

这种写法也叫**双检锁**(两个`if`，双重检测)。