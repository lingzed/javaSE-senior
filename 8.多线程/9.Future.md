Future

【Future】是java中的接口，表示**未来某个时间点**将要获得的结果。它是 Java 并发包中执行异步任务的重要"票据"。

通过这个 `Future` 可以做以下事情：

| 方法名               | 作用                                   |
| -------------------- | -------------------------------------- |
| `get()`              | 阻塞，直到任务完成并返回结果           |
| `get(timeout)`       | 指定时间内等待结果，超时抛异常         |
| `isDone()`           | 判断任务是否完成                       |
| `isCancelled()`      | 判断任务是否被取消                     |
| `cancel(true/false)` | 取消任务，参数表示是否中断运行中的任务 |

异步方法执行，通常是将一个需要执行的任务交给异步调度容器，而这个任务必然是一个函数式接口，因为容器不知道你要具体执行什么逻辑，但是你的执行逻辑必然可以封装为一个方法，那么用函数式接口来接收是最好的结果。

通常一个任务执行可以分为有返回值和无返回值，而异步容器为了能同时满足这两种情况会采用有返回值和无返回值的函数式接口

- Callabel
- Runable

但实际上，你可以选择任何一个无参无返回值的函数式接口来替换Runable，任何一个无参有返回值的函数式接口来替换Callabel，为什么用这两个接口，应该是java多线程设计者为了更加具体的描述异步任务，而且其他函数式接口进行区分所做出的设计。

总之，你要执行异步任务，就把要执行的逻辑封装到Callabel或Runable中，使其变成异步任务。

对于有返回值的异步任务，你把执行逻辑封装到Callabel中，调度容器提供的方法通常都会接收Callabel，而返回一个Future或类似Future功能的其他类。而这样的方法一般叫做提交方法，名字很好理解，你传递一个任务给调度器的过程就像在提交任务一样。这类方法通常有一个特点，不会阻塞线程，提交了任务之后，会立即返回一个结果，但是这个结果不是异常任务的返回结果，你可以理解为一张票据。你可以这样想，你提交的任务必然是跑在其他线程上的，那么当这个线程上的任务执行完成了，你想要拿到结果，你该怎么拿？或者你想在任务执行的过程中做某些事情，你该怎么做？你想要做到这些，你肯定得访问到这个跑任务的线程，而这张票据就是提供了这样的能力，你可以把它理解为你访问这个线程上的任务的控制器，通过这个东西你能拿到方法的返回值，你能操作方法的执行过程，这个东西就是你控制线程上方法的控制器，它实际上是这个操作过程的封装，被封装为了一个类

当我将任务提交给异步容器，任务会立即执行吗？不一定，任务是否会立即执行，需要看异步容器如何调度，如果容器有空余线程，那么任务就能执行，若没有空余线程，那么任务只能等待，而且就算有空余线程，任务也可能不会立即执行，因为当前的CPU执行权可能不是这个线程的。

说回Future，我们可以通过Future拿到异步任务的结果，但是这会阻塞当前的线程，其实这很好理解，任务执行需要耗时，我当前线程叫你这个线程帮我跑异步任务，跟我自己跑这个任务，本质没什么区别，都是要等这个任务跑完，你等我等都一样。只是本来要我等的，变成了你来帮我等，那么我原本要等待的时间就空出来了，我可以利用这个时间去做其他的事情。这才是异步执行的意义。

可是如果我一定要等着你呢？我主线程让你帮我跑之后，我就没什么事情要做了，我就只想要任务的结果，那么我还是要等你。从这点可以看出虽然异步执行了，但还是发生了等待，也就是说异步不会消除等待。这一点，我们后面细说。

既然同步和异步都要等待，那么异步的速度提升体现在哪里？

答案就是体现在整体的等待时间上，整体的等待时间被压缩了。举个例子，我有3给任务A、B、C，A和B耗时2s、C耗时3s，如果我同步执行，因为是串行，我拿到3个任务的结果总体等待时间为2+2+3=7s，而如果我异步执行，3个任务同时进行，那么我拿到3个任务的结果等待的时间就应该是3个任务中耗时最长的那个任务所运行的时间，也就是说我只需要等待3s，比较来看，虽然也是等待，但总体等待时间被极大的压缩了。

这才是异步带来加速的本质。**速度提升发生在任务并发运行的这段时间，而不是你阻塞等待的这段时间。**

这个等待或者是阻塞是不可避免的吗？这里说的阻塞是指拿到异步任务的结果而产生的阻塞。

这种阻塞——**在等待结果的场景下是不可避免的**，因为：

- 你想得到任务的返回值，必须等任务执行完毕才能拿到结果。
- 线程拿不到结果之前，调用 `get()` 的线程自然会被阻塞。

但是我们可以利用回调来避免这种阻塞，让**主线程**不再等待。也就是主线程在提交异步任务的同时，也把拿到异步任务的结果后需要做的事情提交给回调，这样等到异步任务执行完成，由任务的结果触发回调，让回调执行之前提交的回调任务。等到结果然后拿到结果执行逻辑这整个是自动的流程，而且是在其他线程，也就是说主线程的职能被释放了，他就可以去干其他的事情。

本质上把任务交给异步容器去执行的同时也把拿到任务结果后处理的流程交给回调，这样等到异步任务执行完成回调就会自动执行我预先设置好的流程，如此，就不需要主线程去等待结果然后再走流程，这个流程回调帮你走了。

发现了吗？其实就是让别的线程来帮主线程做事情，回调机制也是为了保证别的线程能持续的进行任务，而不会影响到主线程。

那么回调执行在那个线程上？默认是"谁跑任务，谁跑回调"。

在提交异步的时候提交回调，默认是执行异步的这个线程来执行回调：

```java
CompletableFuture.supplyAsync(task)
                 .thenAccept(callback);
```

`task` 和 `callback` 都在 **同一个线程池线程**中执行

如果在提交时候指定线程池，那么由指定的线程池来控制：

```java
ExecutorService myExecutor = Executors.newFixedThreadPool(5);

CompletableFuture
    .supplyAsync(task, myExecutor)
    .thenAcceptAsync(callback, myExecutor); // 回调也用这个池执行
```

- 异步任务在 `myExecutor` 中跑
- 回调也在 `myExecutor` 中跑（甚至是另一个线程）

如果回调也会产生一个结果，而我又要用这个结果来做其他事情，那么主线程是不是又不可避免的阻塞了？

如果主线程想用结果，但又不想阻塞，我们可以再把主线程要做的事情包装成回调，然后连接在上一个回调的后面，让上一个回调的结果来触发此次回调，我们又一次把主线程的职责委托出去了。也就是又加了回调让另一个线程继续保持连续执行。相当于我们构建了一个责任链。

但是如果是主线程必须要用到结果，那么你最终还是得等到回调执行完成，还是阻塞了。

所以：

- 回调能“帮你处理”，你不等
- 但**如果你非得自己亲手用结果，那就得等**（即使你用回调做了一部分处理）

如果主线程接下来要做A、B两件事，A这件事你异步进行，如果A、B之间互不相干B不会用到A的异步结果或者回调结果，那么主线程完全可以不用管A，他只需要去执行B即可，A的整个执行链路完全由另一个线程控制，对应这种情况来来说主线程是没有阻塞的。但是如果A、B相干，B需要A的结果，那么在主线程处理B的时候主线程需要等待A，主线程就被阻塞了，但是主线程又可以把处理B的职责委托给另一个线程，主线程又不阻塞了。

回调解决主线程的等待，其实是转移主线程的等待，让其他线程去等待，实际是回调中的任务在等待，其实等待没有消失只是转移了，如果主线程继续其他任务，其他任务还要等到回调的结果那么可以再次转移，也就是给回调包装一层回调，理论上可以一直包装下去让主线程永远没有等待。

**等待没有消失，只是转移了执行权和等待责任**。

主线程如果继续其他任务，而又需要回调结果，也可以通过再包装一层回调解决。 这就是**回调地狱（callback hell）的原型，也是事件驱动模型的本质**。

**理论上可以一直包装下去，让主线程永远没有等待。**
这正是现代异步编程模型（如 JavaScript 的事件循环、Java 的 `CompletableFuture`）试图构建的一种理想状态：**主线程永远不阻塞，所有逻辑都靠事件触发推进**。

等待本质不会消失，但我们可以转移等待的位置，通过回调链控制流程，使主线程永远不阻塞。
